{{# def.definitions }}
{{# def.errors }}
{{# def.setupKeyword }}
{{# def.$data }}

{{
  var $rule = this
    , $definition = 'definition' + $lvl
    , $rDef = $rule.definition
    , $closingBraces = '';
  var $validate = $rDef.validate;
  var $compile, $macro, $ruleValidate, $validateCode;
}}

{{? $isData && $rDef.$data }}
  {{
    $validateCode = 'keywordValidate' + $lvl;
    var $validateSchema = $rDef.validateSchema;
  }}
  var {{=$definition}} = RULES.custom['{{=$keyword}}'].definition;
  var {{=$validateCode}} = {{=$definition}}.validate;
{{??}}
  {{
    $ruleValidate = useCustomRule.call(it.self, $rule, $schema, it.schema, it);
    if (!$ruleValidate) return;
    $schemaValue = it.topSchemaRef + $schemaPath;
    $validateCode = $ruleValidate.code;
    $compile = $rDef.compile;
    $macro = $rDef.macro;
  }}
{{?}}

{{
  var $ruleErrs = $validateCode + '.errors'
    , $i = 'i' + $lvl
    , $ruleErr = 'ruleErr' + $lvl
    , $asyncKeyword = $rDef.async;

  if ($asyncKeyword && !it.async)
    throw new Error('async keyword in sync schema');
}}


{{? !$macro }}{{=$ruleErrs}} = null;{{?}}
var {{=$errs}} = errors;
var {{=$valid}};

{{## def.callRuleValidate:
  {{=$validateCode}}.call(
    {{? it.opts.passContext }}this{{??}}self{{?}}
    {{? $compile || $rDef.schema === false }}
      , {{=$data}}
    {{??}}
      , {{=$schemaValue}}
      , {{=$data}}
      , {{=it.topSchemaRef}}{{=it.schemaPath}}
    {{?}}
    , {{# def.dataPath }}
    {{# def.passParentData }}
    , rootData
  )
#}}

{{## def.extendErrors:_inline:
  for (var {{=$i}}={{=$errs}}; {{=$i}}<errors; {{=$i}}++) {
    var {{=$ruleErr}} = vErrors[{{=$i}}];
    if ({{=$ruleErr}}.dataPath === undefined)
      {{=$ruleErr}}.dataPath = (dataPath || '') + {{= it.errorPath }};
    {{# _inline ? 'if (\{\{=$ruleErr\}\}.schemaPath === undefined) {' : '' }}
      {{=$ruleErr}}.schemaPath = "{{=$errSchemaPath}}";
    {{# _inline ? '}' : '' }}
    {{? it.opts.verbose }}
      {{=$ruleErr}}.schema = {{=$schemaValue}};
      {{=$ruleErr}}.data = {{=$data}};
    {{?}}
  }
#}}


{{? $isData && $rDef.$data }}
  {{ $closingBraces += '}'; }}
  if ({{=$schemaValue}} === undefined) {
    {{=$valid}} = true;
  } else {
  {{? $validateSchema }}
    {{ $closingBraces += '}'; }}
    {{=$valid}} = {{=$definition}}.validateSchema({{=$schemaValue}});
    if ({{=$valid}}) {
  {{?}}
{{?}}

{{? $macro }}
  {{# def.setupNextLevel }}
  {{
    $it.schema = $ruleValidate.validate;
    $it.schemaPath = '';
  }}
  {{# def.setCompositeRule }}
  {{ var $code = it.validateCode($it).replace(/validate\.schema/g, $validateCode); }}
  {{# def.resetCompositeRule }}
  {{= $code }}
{{??}}
  {{# def.beginDefOut}}
    {{# def.callRuleValidate }}
  {{# def.storeDefOut:def_callRuleValidate }}

  {{? $rDef.errors === false }}
    {{=$valid}} = {{? $asyncKeyword }}await {{?}}{{= def_callRuleValidate }};
  {{??}}
    {{? $asyncKeyword }}
      {{ $ruleErrs = 'customErrors' + $lvl; }}
      var {{=$ruleErrs}} = null;
      try {
        {{=$valid}} = await {{= def_callRuleValidate }};
      } catch (e) {
        {{=$valid}} = false;
        if (e instanceof ValidationError) {{=$ruleErrs}} = e.errors;
        else throw e;
      }
    {{??}}
      {{=$ruleErrs}} = null;
      {{=$valid}} = {{= def_callRuleValidate }};
    {{?}}
  {{?}}
{{?}}

{{? $rDef.modifying }}
  if ({{=$parentData}}) {{=$data}} = {{=$parentData}}[{{=$parentDataProperty}}];
{{?}}

{{= $closingBraces }}

{{## def.notValidationResult:
  {{? $rDef.valid === undefined }}
    !{{? $macro }}{{=$nextValid}}{{??}}{{=$valid}}{{?}}
  {{??}}
    {{= !$rDef.valid }}
  {{?}}
#}}

{{? $rDef.valid }}
  {{? $breakOnError }} if (true) { {{?}}
{{??}}
  if ({{# def.notValidationResult }}) {
    {{ $errorKeyword = $rule.keyword; }}
    {{# def.beginDefOut}}
      {{# def.error:'custom' }}
    {{# def.storeDefOut:def_customError }}

    {{? $macro }}
      {{# def.extraError:'custom' }}
    {{??}}
      {{? $rDef.errors === false}}
        {{= def_customError }}
      {{??}}
        if (Array.isArray({{=$ruleErrs}})) {
          if (vErrors === null) vErrors = {{=$ruleErrs}};
          else vErrors = vErrors.concat({{=$ruleErrs}});
          errors = vErrors.length;
          {{# def.extendErrors:false }}
        } else {
          {{= def_customError }}
        }
      {{?}}
    {{?}}

  } {{? $breakOnError }} else { {{?}}
{{?}}

{{
  function useCustomRule(
    rule,
    schema,
    parentSchema,
    it
  ) {
    const ruleDef = rule.definition;
    
    if (this._opts.validateSchema !== false) {
      it.validateKeywordSchema(it, $keyword, ruleDef);
    }

    var compile = ruleDef.compile,
      macro = ruleDef.macro;

    var validate;
    if (compile) {
      validate = compile.call(this, schema, parentSchema, it);
    } else if (macro) {
      validate = macro.call(this, schema, parentSchema, it);
      if (it.opts.validateSchema !== false) this.validateSchema(validate, true);
    } else {
      validate = ruleDef.validate;
      if (!validate) return;
    }

    /* addCustomRule */
    if (validate === undefined) {
      throw new Error('custom keyword "' + rule.keyword + '"failed to compile');
    }

    var index = it.customRules.length;
    it.customRules[index] = validate;

    return {
      code: "customRule" + index,
      validate,
    };
  }

it.gen.code(out);

}}